= RISC-V Vector Element Groups

*Concept - not part of any standard*


Some vector instructions treat operands as a vector of one or more
_element_ _groups_, where each element group is a fixed number of
elements.  For example, complex numbers can be viewed as a two-element
group (one real element and one imaginary element).  As another
example, an SHA-256 cryptographic operation operates on an 8-element
group of 32-bit elements.

This section describes recommendations and terminology for generic
instruction set design for vector instructions that operate on element
groups.

NOTE: Element groups effectively replace the EDIV concept that was
discussed before ratification of the vector spec, but removed from the
ratified spec.  Element groups are more flexible, supporting a wider
range of group sizes, and avoid having to increase supported SEW for
larger groups.

The _element_ _group_ _size_ is the number of elements in one group.

The element group size is statically encoded in the instruction, often
implicitly as part of the opcode.

NOTE: The vector instructions in the base V vector ISA can be viewed
as all having an element group size of 1 for all operands statically
encoded in the instruction.

NOTE: Many operations only make sense with a certain number of
elements per group (e.g., complex operations require a element group
size of 2 and SHA-256 requires an element group size of 8).

NOTE: Possible future vector instructions that might operate on
variable-sized element groups are not considered here.

The `vtype` SEW can be used to indicate or calculate the effective
element size (EEW) of one or more operands.  Where the operand is an
element group, SEW and EEW refer to the number of bits in each
individual element within a group not the number of bits in the group
as a whole.

Alternatively, the opcode might encode EEW of all operands statically
and ignore the value of SEW when the operation only makes sense for a
single size on each operand.

NOTE: Many operations are only defined for one EEW, e.g., SHA-256
requires EEW=32.  Encoding EEWs statically in the instruction removes
a dynamic dependency on the SEW value and the need to check for errors
in SEW values.  However, ignoring SEW also prevents reuse of the
static opcode with a different dynamic SEW, and in many cases, the SEW
setting will be needed for regular vector instructions used to process
the individual elements in the vector.

Each source and destination operand to a vector instruction might be
defined as either a single element group or a vector of element
groups.  When the operand is a vector of element groups, the `vl`
setting must correspond to an integer multiple of the element group
size, with other values of vl _reserved_.

NOTE: For example, a SHA-256 instruction would require that `vl` is a
multiple of 8.

NOTE: Implementations are recommended to raise an illegal instruction
exception for a `vl` value that is not a multiple of the element group
size.

NOTE: For power-of-2 element group sizes, `vl` error checking simply
involves checking that least-significant bits are zero.  Supporting
element group sizes that are not a power of two is problematic for
many reasons, not only `vl` error checking.  For LMUL>1,
non-power-of-2 element group sizes can result in groups straddling the
individual vector registers in a vector register group.  Also,
conventional stripmining control with `vsetvl` will result in
fractional element groups, and so special logic would be needed.
Hence we do not anticipate supporting non-power-of-2 element group
sizes.

The `vtype` LMUL setting can be used to indicate or calculate the
effective length multiplier (EMUL) for one or more operands.  Element
group instructions tend to exhibit a much wider range of relationships
between various operand EEW/EMUL values.  For example, an instruction
might take a vector of length N of 4-element groups with EEW=8b and
reduce each group to produce a vector length N of 1-element groups
with EEW=32b. In this case, the input and output EMUL values are equal
even though the EEW settings differ by a factor of 4.

Each source and destination operand to a vector instruction may have a
different element group size, different EMUL, and/or different EEW.

The _element_ _group_ _width_ (EGW) is the number of bits in the
element group as a whole.  For example, SHA-256 has an EGW of 256, due
to an element group size of 8 with EEW=32.  It is possible to use LMUL
to concatenate multiple vector registers together to support larger
EGW>VLEN.

NOTE: Implementations may choose not to support instructions with
EGW>VLEN due to implementation complexity.

NOTE: If software using large EGW instructions wants to be portable
across across a range of implementations, some of which may have
VLEN<EGW and hence require LMUL>1, then software can only use a subset
of the architectural registers.  Profiles can set minimum VLEN
requirements to inform authors of portable software.

NOTE: Element group operations by their nature will gather data from
across a wider portion of a vector datapath than regular vector
instructions.  Some element group instructions might allow temporal
execution of individual element operations in a larger group, while
others will require all EGW bits of a group to be presented to a
functional unit at the same time.

Some element-group instructions might not support masking.  Other
instructions might define mask behavior in terms of a _mask_ _element_
_group_ (e.g., update destination element group if any or all mask
bits in mask element group are set, and/or update one or more
destination mask values in a mask element group on basis of element
group predicate).
